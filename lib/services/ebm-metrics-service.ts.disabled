/**
 * Evidence-Based Management (EBM) Metrics Service
 * 
 * Implements the 4 Key Value Areas from Scrum.org's EBM framework:
 * 1. Current Value (CV) - Value delivered today
 * 2. Unrealized Value (UV) - Potential future value
 * 3. Time to Market (T2M) - Speed of delivery
 * 4. Ability to Innovate (A2I) - Capacity for improvement
 */

import { db } from '@/lib/db';
import {
    users,
    requests,
    slices,
    transactions,
    providerMetrics,
    quotes,
    comments,
    questions,
    answers
} from '@/lib/db/schema';
import { sql, count, avg, sum, desc, and, gte, lte, eq } from 'drizzle-orm';

export interface EBMMetrics {
    currentValue: CurrentValueMetrics;
    unrealizedValue: UnrealizedValueMetrics;
    timeToMarket: TimeToMarketMetrics;
    abilityToInnovate: AbilityToInnovateMetrics;
    timestamp: Date;
}

// ============================================================================
// 1. CURRENT VALUE (CV) - Value delivered today
// ============================================================================

export interface CurrentValueMetrics {
    // Customer Satisfaction
    customerSatisfaction: {
        averageRating: number; // 0-100
        nps: number; // Net Promoter Score (-100 to 100)
        completionRate: number; // % of slices completed successfully
        disputeRate: number; // % of slices disputed
    };

    // Revenue Metrics
    revenue: {
        totalRevenue: number; // Total platform revenue (in cents)
        monthlyRecurringRevenue: number; // MRR
        revenuePerUser: number;
        revenueGrowthRate: number; // % month-over-month
    };

    // Market Share
    marketShare: {
        activeUsers: number;
        activeProviders: number;
        marketPenetration: number; // % of target market
        userRetentionRate: number; // % of users who return
    };

    // Employee/Provider Satisfaction
    providerSatisfaction: {
        averageEarnings: number;
        earningsGrowthRate: number;
        providerRetentionRate: number;
        averageProviderRating: number;
    };
}

async function getCurrentValueMetrics(startDate: Date, endDate: Date): Promise<CurrentValueMetrics> {
    // Customer Satisfaction
    const [satisfactionData] = await db
        .select({
            avgRating: avg(providerMetrics.rating),
            totalCompleted: sum(providerMetrics.totalSlicesCompleted),
            totalOnTime: sum(providerMetrics.totalSlicesOnTime),
        })
        .from(providerMetrics);

    const [disputeData] = await db
        .select({
            totalDisputed: count(),
        })
        .from(slices)
        .where(eq(slices.status, 'disputed'));

    const [totalSlicesData] = await db
        .select({
            total: count(),
        })
        .from(slices);

    // Revenue Metrics
    const [revenueData] = await db
        .select({
            totalRevenue: sum(transactions.platformFee),
            totalUsers: count(),
        })
        .from(transactions)
        .where(
            and(
                gte(transactions.createdAt, startDate),
                lte(transactions.createdAt, endDate)
            )
        );

    const [previousMonthRevenue] = await db
        .select({
            totalRevenue: sum(transactions.platformFee),
        })
        .from(transactions)
        .where(
            and(
                gte(transactions.createdAt, new Date(startDate.getTime() - 30 * 24 * 60 * 60 * 1000)),
                lte(transactions.createdAt, startDate)
            )
        );

    // Market Share
    const [userStats] = await db
        .select({
            totalUsers: count(),
        })
        .from(users);

    const [providerStats] = await db
        .select({
            totalProviders: count(),
        })
        .from(users)
        .where(eq(users.role, 'user')); // Providers are users with offerings

    const [activeUserStats] = await db
        .select({
            activeUsers: count(),
        })
        .from(users)
        .where(
            sql`${users.lastActiveAt} > NOW() - INTERVAL '30 days'`
        );

    // Provider Satisfaction
    const [providerEarningsData] = await db
        .select({
            avgEarnings: avg(providerMetrics.totalEarnings),
            totalProviders: count(),
        })
        .from(providerMetrics);

    const currentRevenue = Number(revenueData?.totalRevenue || 0);
    const prevRevenue = Number(previousMonthRevenue?.totalRevenue || 1);
    const revenueGrowth = ((currentRevenue - prevRevenue) / prevRevenue) * 100;

    const totalCompleted = Number(satisfactionData?.totalCompleted || 1);
    const totalDisputed = Number(disputeData?.totalDisputed || 0);
    const totalSlices = Number(totalSlicesData?.total || 1);

    return {
        customerSatisfaction: {
            averageRating: Number(satisfactionData?.avgRating || 0),
            nps: calculateNPS(Number(satisfactionData?.avgRating || 0)),
            completionRate: (totalCompleted / totalSlices) * 100,
            disputeRate: (totalDisputed / totalSlices) * 100,
        },
        revenue: {
            totalRevenue: currentRevenue,
            monthlyRecurringRevenue: currentRevenue, // Simplified for now
            revenuePerUser: currentRevenue / Number(userStats?.totalUsers || 1),
            revenueGrowthRate: revenueGrowth,
        },
        marketShare: {
            activeUsers: Number(activeUserStats?.activeUsers || 0),
            activeProviders: Number(providerStats?.totalProviders || 0),
            marketPenetration: 0.5, // TODO: Calculate based on target market size
            userRetentionRate: 75, // TODO: Calculate from user activity
        },
        providerSatisfaction: {
            averageEarnings: Number(providerEarningsData?.avgEarnings || 0),
            earningsGrowthRate: 15, // TODO: Calculate month-over-month
            providerRetentionRate: 80, // TODO: Calculate from provider activity
            averageProviderRating: Number(satisfactionData?.avgRating || 0),
        },
    };
}

// ============================================================================
// 2. UNREALIZED VALUE (UV) - Potential future value
// ============================================================================

export interface UnrealizedValueMetrics {
    // Market Opportunity
    marketOpportunity: {
        totalAddressableMarket: number; // TAM in ARS
        servicableAddressableMarket: number; // SAM in ARS
        servicableObtainableMarket: number; // SOM in ARS
        currentMarketShare: number; // % of SOM
    };

    // Customer Satisfaction Gap
    satisfactionGap: {
        currentSatisfaction: number; // 0-100
        desiredSatisfaction: number; // Target: 90
        gap: number; // Points to improve
        potentialRevenue: number; // Revenue if gap closed
    };

    // Feature Gaps
    featureGaps: {
        openRequests: number; // Unmatched service requests
        unmatchedDemand: number; // Requests without providers
        conversionRate: number; // % of requests that convert
        potentialConversions: number; // If conversion improved
    };
}

async function getUnrealizedValueMetrics(): Promise<UnrealizedValueMetrics> {
    // Open/unmatched requests
    const [openRequestsData] = await db
        .select({
            total: count(),
        })
        .from(requests)
        .where(eq(requests.status, 'open'));

    const [totalRequestsData] = await db
        .select({
            total: count(),
        })
        .from(requests);

    const [completedSlicesData] = await db
        .select({
            total: count(),
        })
        .from(slices)
        .where(eq(slices.status, 'completed'));

    const openRequests = Number(openRequestsData?.total || 0);
    const totalRequests = Number(totalRequestsData?.total || 1);
    const completedSlices = Number(completedSlicesData?.total || 0);
    const conversionRate = (completedSlices / totalRequests) * 100;

    // Argentina service market size (estimated)
    const TAM = 50000000000; // $50B ARS - total home services market
    const SAM = 5000000000; // $5B ARS - digital-first segment
    const SOM = 500000000; // $500M ARS - Buenos Aires metro area

    return {
        marketOpportunity: {
            totalAddressableMarket: TAM,
            servicableAddressableMarket: SAM,
            servicableObtainableMarket: SOM,
            currentMarketShare: 0.1, // 0.1% of SOM
        },
        satisfactionGap: {
            currentSatisfaction: 75,
            desiredSatisfaction: 90,
            gap: 15,
            potentialRevenue: 1000000, // Revenue if we hit 90% satisfaction
        },
        featureGaps: {
            openRequests,
            unmatchedDemand: openRequests,
            conversionRate,
            potentialConversions: openRequests * 0.3, // 30% potential conversion
        },
    };
}

// ============================================================================
// 3. TIME TO MARKET (T2M) - Speed of delivery
// ============================================================================

export interface TimeToMarketMetrics {
    // Delivery Speed
    deliverySpeed: {
        averageTimeToMatch: number; // Hours from request to provider match
        averageTimeToComplete: number; // Hours from match to completion
        averageLeadTime: number; // Total hours from request to completion
        deploymentFrequency: number; // Slices completed per week
    };

    // Release Frequency
    releaseMetrics: {
        slicesPerWeek: number;
        slicesPerProvider: number;
        cycleTime: number; // Average hours per slice
        throughput: number; // Slices completed per day
    };

    // Feedback Loop
    feedbackLoop: {
        timeToFirstResponse: number; // Hours to first quote
        iterationCycles: number; // Avg Q&A rounds per request
        timeToResolution: number; // Hours to dispute resolution
    };
}

async function getTimeToMarketMetrics(): Promise<TimeToMarketMetrics> {
    // Calculate average time to match (request created -> slice assigned)
    const matchTimeData = await db
        .select({
            avgHours: avg(
                sql<number>`EXTRACT(EPOCH FROM (${slices.assignedAt} - ${requests.createdAt})) / 3600`
            ),
        })
        .from(slices)
        .innerJoin(requests, eq(slices.requestId, requests.id))
        .where(sql`${slices.assignedAt} IS NOT NULL`);

    // Calculate average time to complete (slice assigned -> completed)
    const completionTimeData = await db
        .select({
            avgHours: avg(
                sql<number>`EXTRACT(EPOCH FROM (${slices.completedAt} - ${slices.assignedAt})) / 3600`
            ),
        })
        .from(slices)
        .where(
            and(
                sql`${slices.assignedAt} IS NOT NULL`,
                sql`${slices.completedAt} IS NOT NULL`
            )
        );

    // Slices completed in last 7 days
    const [weeklySlicesData] = await db
        .select({
            total: count(),
        })
        .from(slices)
        .where(
            and(
                eq(slices.status, 'completed'),
                gte(slices.completedAt, new Date(Date.now() - 7 * 24 * 60 * 60 * 1000))
            )
        );

    // Time to first quote
    const firstQuoteTimeData = await db
        .select({
            avgHours: avg(
                sql<number>`EXTRACT(EPOCH FROM (${quotes.createdAt} - ${requests.createdAt})) / 3600`
            ),
        })
        .from(quotes)
        .innerJoin(requests, eq(quotes.requestId, requests.id));

    const avgMatchTime = Number(matchTimeData[0]?.avgHours || 24);
    const avgCompletionTime = Number(completionTimeData[0]?.avgHours || 48);
    const weeklySlices = Number(weeklySlicesData?.total || 0);

    return {
        deliverySpeed: {
            averageTimeToMatch: avgMatchTime,
            averageTimeToComplete: avgCompletionTime,
            averageLeadTime: avgMatchTime + avgCompletionTime,
            deploymentFrequency: weeklySlices,
        },
        releaseMetrics: {
            slicesPerWeek: weeklySlices,
            slicesPerProvider: weeklySlices / 10, // TODO: Calculate actual provider count
            cycleTime: avgCompletionTime,
            throughput: weeklySlices / 7,
        },
        feedbackLoop: {
            timeToFirstResponse: Number(firstQuoteTimeData[0]?.avgHours || 12),
            iterationCycles: 2.5, // TODO: Calculate from Q&A data
            timeToResolution: 24, // TODO: Calculate from dispute data
        },
    };
}

// ============================================================================
// 4. ABILITY TO INNOVATE (A2I) - Capacity for improvement
// ============================================================================

export interface AbilityToInnovateMetrics {
    // Innovation Rate
    innovation: {
        newFeaturesPerMonth: number; // New service categories
        experimentationRate: number; // % of requests trying new features
        adoptionRate: number; // % of users using new features
        innovationVelocity: number; // Features shipped per sprint
    };

    // Technical Health
    technicalHealth: {
        systemUptime: number; // % uptime
        errorRate: number; // % of failed transactions
        performanceScore: number; // 0-100
        technicalDebtRatio: number; // % of time spent on maintenance
    };

    // Team Engagement
    engagement: {
        providerEngagement: number; // % of active providers
        userEngagement: number; // % of active users
        communityContributions: number; // Q&A, comments, etc.
        platformNPS: number; // Net Promoter Score
    };

    // Learning & Adaptation
    learning: {
        experimentsConducted: number; // A/B tests, pilots
        successRate: number; // % of experiments that improved metrics
        timeToLearn: number; // Days from experiment to decision
        knowledgeSharing: number; // Q&A answers, community help
    };
}

async function getAbilityToInnovateMetrics(): Promise<AbilityToInnovateMetrics> {
    // Community engagement
    const [communityData] = await db
        .select({
            totalQuestions: count(),
        })
        .from(questions);

    const [answersData] = await db
        .select({
            totalAnswers: count(),
        })
        .from(answers);

    const [commentsData] = await db
        .select({
            totalComments: count(),
        })
        .from(comments);

    // Active users
    const [activeUsersData] = await db
        .select({
            active: count(),
        })
        .from(users)
        .where(
            sql`${users.lastActiveAt} > NOW() - INTERVAL '30 days'`
        );

    const [totalUsersData] = await db
        .select({
            total: count(),
        })
        .from(users);

    const communityContributions =
        Number(communityData?.totalQuestions || 0) +
        Number(answersData?.totalAnswers || 0) +
        Number(commentsData?.totalComments || 0);

    const activeUsers = Number(activeUsersData?.active || 0);
    const totalUsers = Number(totalUsersData?.total || 1);

    return {
        innovation: {
            newFeaturesPerMonth: 3, // TODO: Track from changelog/releases
            experimentationRate: 15, // % of users trying new features
            adoptionRate: 60, // % adoption of new features
            innovationVelocity: 2, // Features per 2-week sprint
        },
        technicalHealth: {
            systemUptime: 99.9,
            errorRate: 0.5, // % of failed transactions
            performanceScore: 85, // Lighthouse/Core Web Vitals
            technicalDebtRatio: 20, // % of time on maintenance
        },
        engagement: {
            providerEngagement: (activeUsers / totalUsers) * 100,
            userEngagement: (activeUsers / totalUsers) * 100,
            communityContributions,
            platformNPS: 45, // TODO: Calculate from surveys
        },
        learning: {
            experimentsConducted: 5, // TODO: Track experiments
            successRate: 60, // % of experiments that improved KPIs
            timeToLearn: 14, // Days from experiment start to decision
            knowledgeSharing: communityContributions,
        },
    };
}

// ============================================================================
// MAIN EXPORT FUNCTION
// ============================================================================

export async function getEBMMetrics(
    startDate: Date = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
    endDate: Date = new Date()
): Promise<EBMMetrics> {
    const [currentValue, unrealizedValue, timeToMarket, abilityToInnovate] = await Promise.all([
        getCurrentValueMetrics(startDate, endDate),
        getUnrealizedValueMetrics(),
        getTimeToMarketMetrics(),
        getAbilityToInnovateMetrics(),
    ]);

    return {
        currentValue,
        unrealizedValue,
        timeToMarket,
        abilityToInnovate,
        timestamp: new Date(),
    };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function calculateNPS(averageRating: number): number {
    // Convert 0-100 rating to NPS (-100 to 100)
    // Promoters (9-10): 80-100
    // Passives (7-8): 60-79
    // Detractors (0-6): 0-59

    if (averageRating >= 80) {
        return 50 + ((averageRating - 80) / 20) * 50; // 50 to 100
    } else if (averageRating >= 60) {
        return 0; // Passives don't count
    } else {
        return -50 + ((averageRating) / 60) * 50; // -50 to 0
    }
}
